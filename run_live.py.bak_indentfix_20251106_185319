# === AI start helper (idempotent) ===
import threading, time
def _ai_try_start(ctrl):
    try:
        globals()['controller'] = ctrl
    except Exception:
        pass
    try:
        print("[ai] export: controller -> globals()")
    except Exception:
        pass
    try:
        if not getattr(ctrl, "_ai_loop_started", False):
            start_ai_loop(ctrl)
            print("[ai] loop start requested")
    except Exception as _e:
        print("[ai] start_ai_loop failed:", _e)

# Poller as last resort: tries for ~2 min then stops
def _ai_poll_start():
    def _poll():
        for _ in range(120):
            try:
                ctrl = globals().get("controller", None)
                if ctrl is not None and not getattr(ctrl, "_ai_loop_started", False):
                    print("[ai] poller: controller found -> start")
                    start_ai_loop(ctrl)
                    print("[ai] loop started (poller)")
                    return
            except Exception as _e:
                print("[ai] poller error:", _e)
            time.sleep(1.0)
    threading.Thread(target=_poll, name="ai_poll", daemon=True).start()
_ai_poll_start()
# === /AI start helper ===
# ===== [PATCH] AI loud binder =====
print("[ai] hook: top-of-file reached")
try:
    from ai.alpha_loop import start_ai_loop
    import threading, time, traceback
    print("[ai] hook: import ai.alpha_loop OK")
    def _ex_ai_binder():
        print("[ai] binder: thread online (waiting for controller)")
        for i in range(0, 300):  # wait up to 5 minutes
            try:
                ctrl = globals().get("controller", None)
                if ctrl is not None:
                    print("[ai] binder: controller found -> starting AI loop")
                    try:
                        start_ai_loop(ctrl)
                        print("[ai] loop started")
                    except Exception as e:
                        print("[ai] ERROR: start_ai_loop failed:", e)
                        traceback.print_exc()
                    return
            except Exception as e:
                print("[ai] binder error:", e)
                traceback.print_exc()
            time.sleep(1.0)
        print("[ai] binder: timeout (controller not found)")
    threading.Thread(target=_ex_ai_binder, name="ai_binder", daemon=True).start()
except Exception as _e:
    print("[ai] hook: import failed:", _e)
# ===== [/PATCH] AI loud binder =====
# ===== [PATCH] AI binder: wait for controller, then start loop =====
try:
    from ai.alpha_loop import start_ai_loop
    import threading, time
    def _ex_start_ai_when_ready():
        def _poll():
            for _ in range(180):  # 3 minutes should be plenty
                try:
                    ctrl = globals().get("controller", None)
                    if ctrl is not None:
                        print("[ai] binding                                ")
                        try:
                            start_ai_loop(ctrl)
                            print("[ai] loop bound")
                        except Exception as e:
                            print(f"[ai] bind failed: {e}")
                        return
                except Exception as e:
                    print(f"[ai] binder error: {e}")
                time.sleep(1.0)
            print("[ai] binding timeout (controller not found)")
        threading.Thread(target=_poll, name="ai_binder", daemon=True).start()
    _ex_start_ai_when_ready()
except Exception as _e:
    try: print(f"[ai] binder import failed: {_e}")
    except Exception: pass
# ===== [/PATCH] =====
from ai.alpha_loop import start_ai_loop
#!/usr/bin/env python3
"""
run_live.py                                                                                    live runner with:
- Tk dashboard attach
- Execution logging (TradeLogger or CSV)
- FTMO enforcer (env-configured)
- Per-symbol entry guards (in-flight + cooldown)
- SL/TP placement:
                                                                           SLTP_MODE=FIXED                                                                                          FIXED_PIPS + TP_MULT
                                                                           SLTP_MODE=ATR                                                                                            ATR_TF/ATR_PERIOD/ATR_BARS + ATR_MULT_SL/ATR_MULT_TP (+ ATR_MIN_PIPS)
- Sizing:
                                                                           SIZING_MODE=FIXED_LOT                                                                                          LOT_SIZE
                                                                           SIZING_MODE=ATR_RISK                                                                                           RISK_PCT (risk % per trade) using SL distance (ATR/FIXED)
                                                                           NEW: per-symbol overrides via env: RISK_PCT_<CANON>, SIZE_MIN_<CANON>, SIZE_MAX_<CANON>
- Robust success detection: MT5 retcode 10009 (                                                                             Request executed                                                                      ) counts as OK
- GUI shows live Last Price per symbol
"""

import os, sys, time, json, threading, traceback, argparse, datetime
from typing import Dict, Any, List, Optional, Tuple
from pathlib import Path

# ---------------- .env loader ----------------
def load_dotenv(path: str = ".env") -> None:
    if not os.path.exists(path):
        return
    try:
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                s = line.strip()
                if not s or s.startswith("#") or "=" not in s:
                    continue
                k, v = s.split("=", 1)
                k = k.strip(); v = v.strip()
                if (v.startswith('"') and v.endswith('"')) or (v.startswith("'") and v.endswith("'")):
                    v = v[1:-1]
                os.environ.setdefault(k, v)
    except Exception:
        print("[env] warning: failed to parse .env", file=sys.stderr)

load_dotenv(".env")

# ------------- helpers -------------
def getenv_float(name: str, default: float) -> float:
    try: return float(os.environ.get(name, default))
    except Exception: return float(default)

def getenv_int(name: str, default: int) -> int:
    try: return int(float(os.environ.get(name, default)))
    except Exception: return int(default)

def getenv_bool(name: str, default: bool) -> bool:
    v = os.environ.get(name, None)
    if v is None: return default
    return str(v).strip().lower() in ("1","true","yes","y","on")

def parse_symbols(env_value: Optional[str]) -> List[str]:
    if not env_value: return []
    return [p.strip() for p in env_value.split(",") if p.strip()]

def _retcode_ok(retcode, comment: Optional[str]) -> bool:
    try:
        if retcode == 10009:  # TRADE_RETCODE_DONE
            return True
    except Exception:
        pass
    if comment and "Request executed" in str(comment):
        return True
    return False

# ------------- optional imports -------------
MT5 = None
try:
    import MetaTrader5 as _mt5
    MT5 = _mt5
except Exception:
    MT5 = None

Adapter = None
try:
    from brokers.mt5_adapter import MT5Adapter as _Adapter
    Adapter = _Adapter
except Exception as e:
    print(f"[brokers] adapter import failed: {e}")

FTMO = None
try:
    from risk.ftmo_enforcer import FTMOEnforcer as _FTMO
    FTMO = _FTMO
except Exception as e:
    print(f"[risk] ftmo_enforcer import failed: {e}")

MiniDashboard = None
try:
    from ui.dashboard import MiniDashboard as _MiniDashboard
    MiniDashboard = _MiniDashboard
except Exception as e:
    print(f"[ui] dashboard import failed: {e}")

ATR_HELPER = None
try:
    from tools.atr_helper import get_atr as _get_atr
    ATR_HELPER = _get_atr
except Exception as e:
    ATR_HELPER = None
    print(f"[tools] atr_helper unavailable: {e}")

POS_SIZER = None
try:
    from tools.position_sizer import compute_lot as _compute_lot
    POS_SIZER = _compute_lot
except Exception as e:
    POS_SIZER = None
    print(f"[tools] position_sizer unavailable: {e}")

# ------------- logging -------------
class _CsvFallbackLogger:
    def __init__(self, csv_path: Path):
        self.csv_path = Path(csv_path)
        self.csv_path.parent.mkdir(parents=True, exist_ok=True)
        if not self.csv_path.exists() or self.csv_path.stat().st_size == 0:
            self.csv_path.write_text("ts,iso,profile,symbol,side,volume,price,retcode,comment,ticket,reason,extra\n", encoding="utf-8")
    def log(self, **kwargs):
        ts = time.time()
        iso = datetime.datetime.utcfromtimestamp(ts).isoformat()
        row = {
            "ts": f"{ts:.3f}",
            "iso": iso,
            "profile": kwargs.get("profile",""),
            "symbol": kwargs.get("symbol",""),
            "side": kwargs.get("side",""),
            "volume": kwargs.get("volume",""),
            "price": kwargs.get("price",""),
            "retcode": kwargs.get("retcode",""),
            "comment": kwargs.get("comment",""),
            "ticket": kwargs.get("ticket",""),
            "reason": kwargs.get("reason",""),
            "extra": json.dumps(kwargs.get("extra", {}), ensure_ascii=False),
        }
        with self.csv_path.open("a", encoding="utf-8", newline="") as f:
            f.write(",".join([str(row[k]) for k in ("ts","iso","profile","symbol","side","volume","price","retcode","comment","ticket","reason","extra")]) + "\n")

class ExecLogger:
    def __init__(self, profile: str, enabled: bool = True):
        self.profile = profile
        self.enabled = enabled
        self._impl = None
        if not enabled:
            print("[logger] execution logging disabled")
            return
        try:
            from trade_logger import TradeLogger
            data_dir = Path("data"); data_dir.mkdir(parents=True, exist_ok=True)
            self._impl = TradeLogger(csv_path=data_dir / "trades.csv", db_path=data_dir / "trades.db")
            print("[logger] using TradeLogger (csv+sqlite)")
        except Exception as e:
            print(f"[logger] TradeLogger unavailable ({e}); using CSV fallback")
            self._impl = _CsvFallbackLogger(Path("data") / "trades.csv")
    def log_event(self, **kwargs):
        if not self.enabled or not self._impl:
            return
        kwargs.setdefault("profile", self.profile)
        try:
            if hasattr(self._impl, "log_event"): self._impl.log_event(**kwargs)
            elif hasattr(self._impl, "log"):    self._impl.log(**kwargs)
        except Exception as e:
            print(f"[logger] log_event failed: {e}")

# ------------- controller -------------
class TradingController:
    def __init__(self, profile: str, adapter, ftmo_guard, exec_logger: ExecLogger, args: argparse.Namespace):
        self.profile = profile
        self.adapter = adapter
        self.ftmo = ftmo_guard
        self.exec_logger = exec_logger
        self.args = args

        self._running = False
        self._autopause = False
        self._stop = False
        self._t0 = time.time()
        self._last_hb_print = 0.0

        # Strategy thresholds
        self.MIN_CONF = getenv_float("MIN_CONF", 0.50)

        # Guardrails
        self.ENTRY_COOLDOWN_SEC = getenv_float("ENTRY_COOLDOWN_SEC", 30.0)
        self.INFLIGHT_SEC = getenv_float("INFLIGHT_SEC", 2.0)

        # Sizing (global defaults)
        self.SIZING_MODE = os.environ.get("SIZING_MODE", "FIXED_LOT").upper()
        self.LOT_SIZE = getenv_float("LOT_SIZE", 0.10)   # when FIXED_LOT
        self.RISK_PCT = getenv_float("RISK_PCT", 0.5)    # when ATR_RISK
        self.SIZE_MIN = getenv_float("SIZE_MIN", 0.0)    # optional clamp
        self.SIZE_MAX = getenv_float("SIZE_MAX", 0.0)

        # SLTP config
        self.SLTP_MODE = os.environ.get("SLTP_MODE", "FIXED").upper()
        self.FIXED_PIPS = getenv_float("FIXED_PIPS", 100.0)
        self.TP_MULT = getenv_float("TP_MULT", 2.0)

        # ATR config
        self.ATR_TF = os.environ.get("ATR_TF", "M5")
        self.ATR_PERIOD = getenv_int("ATR_PERIOD", 14)
        self.ATR_BARS = getenv_int("ATR_BARS", 300)
        self.ATR_MULT_SL = getenv_float("ATR_MULT_SL", 1.0)
        self.ATR_MULT_TP = getenv_float("ATR_MULT_TP", 2.0)
        self.ATR_MIN_PIPS = getenv_float("ATR_MIN_PIPS", 0.0)

        # Symbols & mapping
        self._canonical_to_broker: Dict[str,str] = {}
        self._broker_to_canon: Dict[str,str] = {}
        self._symbols: List[str] = []

        # Guard state
        self._next_allowed: Dict[str, float] = {}
        self._inflight_until: Dict[str, float] = {}

        print("[controller] RESUME")
        # [AI] hook after RESUME
_ai_try_start(self)
        # [AI] hook after ready (paused)
_ai_try_start(self)

    # ---- controls ----
    def resume(self):
        self._running = True
        print("[controller] RESUME")    def pause(self): self._running = False; print("[controller] PAUSE")
    def set_autopause(self, v: bool): self._autopause = bool(v); print(f"[controller] autopause                                                                                          {self._autopause}")
    def shutdown(self): self._stop = True; print("[controller] shutdown requested")

    # MIN_CONF hooks for slider
    def set_min_conf(self, v: float): self.MIN_CONF = max(0.0, min(1.0, float(v)))
    def get_min_conf(self) -> float: return float(self.MIN_CONF)
    def set_param(self, name: str, value):
        if name == "MIN_CONF": self.set_min_conf(float(value))
    def get_param(self, name: str):
        if name == "MIN_CONF": return self.get_min_conf()
        return None

    # ---- status for GUI ----
    def get_status(self) -> Dict[str, Any]:
        ftmo_text = "N/A"
        try:
            if self.ftmo:
                ftmo_text = self.ftmo.status_text()
        except Exception: pass

        open_count = 0
        try:
            if MT5:
                pos = MT5.positions_get()
                open_count = len(pos) if pos else 0
        except Exception: pass

        # Cooldown summary
        now = time.time()
        cd_secs = [max(0.0, ts - now) for ts in self._next_allowed.values()]
        cd_secs = [x for x in cd_secs if x >= 0.5]
        soonest = min(cd_secs) if cd_secs else 0.0

        # Symbol rows
        sym_rows = []
        for canon in self._symbols:
            broker = self._canonical_to_broker.get(canon, canon)
            last_px = None
            try:
                if MT5:
                    t = MT5.symbol_info_tick(broker)
                    if t:
                        bid = getattr(t, "bid", None); ask = getattr(t, "ask", None)
                        if bid is not None and ask is not None: last_px = (float(bid)+float(ask))/2.0
                        elif bid is not None: last_px = float(bid)
                        elif ask is not None: last_px = float(ask)
            except Exception: last_px = None

            sym_rows.append({"canonical": canon, "broker": broker, "state":"", "last_price": last_px, "conf": None, "action":"IDLE"})

        hb_age = (time.time() - self._t0) if self._running else 0.0
        return {
            "running": self._running,
            "heartbeat_age_sec": hb_age,
            "ai_conf": self.MIN_CONF,
            "open_positions": open_count,
            "ftmo_one_liner": (ftmo_text + (f" | cd_min={soonest:0.0f}s" if soonest > 0 else "")),
            "symbols": sym_rows,
        }

    # ---- loop ----
    def run(self):
        print("[controller] RESUME")
        # [AI] hook after RESUME
_ai_try_start(self)
        while not self._stop:
            time.sleep(0.25)
            if not self._running: continue

            now = time.time()
            if now - self._last_hb_print > 5.0:
                self._last_hb_print = now
                s_sltp = (f"FIXED({self.FIXED_PIPS:0.1f}p,{self.TP_MULT:0.2f}x)"
                          if self.SLTP_MODE != "ATR" else
                          f"ATR({self.ATR_TF},P{self.ATR_PERIOD},x{self.ATR_MULT_SL:0.2f}/{self.ATR_MULT_TP:0.2f})")
                s_size = (f"FIXED_LOT({self.LOT_SIZE:0.2f})" if self.SIZING_MODE != "ATR_RISK"
                          else f"ATR_RISK({self._risk_pct_for_banner():0.2f}%)")
                print(f"[hb] running MIN_CONF={self.MIN_CONF:0.2f}  cooldown={self.ENTRY_COOLDOWN_SEC:0.0f}s inflight={self.INFLIGHT_SEC:0.1f}s  SLTP={s_sltp}  SIZE={s_size}")

            # FTMO autopause
            try:
                if self.ftmo and getattr(self.ftmo, "violated", False):
                    self._running = False
                    print("[ftmo] violation => autopause")
            except Exception:
                pass
            # strategy loop placeholder

    def _risk_pct_for_banner(self) -> float:
        """If we have mixed overrides, keep the banner on global RISK_PCT to avoid confusion."""
        return float(self.RISK_PCT)

    # ---- setup ----
    def attach_symbols(self, canonical: List[str], mapping_overrides: Dict[str,str]):
        self._symbols = list(canonical)
        self._canonical_to_broker.clear()
        self._broker_to_canon.clear()
        for c in self._symbols:
            b = mapping_overrides.get(c)
            if not b: b = c + "USD" if not c.endswith("USD") else c
            self._canonical_to_broker[c] = b
            self._broker_to_canon[b] = c
            self._next_allowed[b] = 0.0
            self._inflight_until[b] = 0.0

    def mt5_select_all(self):
        if not MT5: return
        try:
            for b in self._canonical_to_broker.values():
                MT5.symbol_select(b, True)
        except Exception: pass

    # ---- guards ----
    def _guard_check(self, symbol: str) -> Tuple[bool, str, float]:
        now = time.time()
        if now < self._inflight_until.get(symbol, 0.0):
            return False, "INFLIGHT", self._inflight_until[symbol] - now
        if now < self._next_allowed.get(symbol, 0.0):
            return False, "COOLDOWN", self._next_allowed[symbol] - now
        return True, "", 0.0

    def _guard_mark_after_attempt(self, symbol: str):
        self._inflight_until[symbol] = time.time() + max(0.0, float(self.INFLIGHT_SEC))

    def _guard_mark_after_order(self, symbol: str):
        self._next_allowed[symbol] = time.time() + max(0.0, float(self.ENTRY_COOLDOWN_SEC))

    # ---- price/point ----
    def _symbol_point(self, symbol: str) -> float:
        try:
            info = MT5.symbol_info(symbol) if MT5 else None
            if info and getattr(info, "point", 0.0) > 0:
                return float(info.point)
        except Exception: pass
        return 0.01

    # ---- SL/TP calculators ----
    def _compute_sltp_fixed(self, side: str, entry_price: float, symbol: str) -> Tuple[Optional[float], Optional[float]]:
        p = self._symbol_point(symbol)
        sl_dist = max(0.0, float(self.FIXED_PIPS)) * p
        tp_dist = sl_dist * max(0.0, float(self.TP_MULT))
        if side.upper() == "BUY": sl = entry_price - sl_dist; tp = entry_price + tp_dist
        else:                      sl = entry_price + sl_dist; tp = entry_price - tp_dist
        return (round(sl, 5), round(tp, 5))

    def _compute_sltp_atr(self, side: str, entry_price: float, symbol: str) -> Tuple[Optional[float], Optional[float]]:
        if not ATR_HELPER: return None, None
        try:
            atr_value, _ = ATR_HELPER(symbol, period=int(self.ATR_PERIOD), timeframe=self.ATR_TF, bars=int(self.ATR_BARS))
        except Exception:
            atr_value = None
        if not atr_value or atr_value <= 0: return None, None
        sl_dist = float(self.ATR_MULT_SL) * float(atr_value)
        tp_dist = float(self.ATR_MULT_TP) * float(atr_value)
        if self.ATR_MIN_PIPS and self.ATR_MIN_PIPS > 0:
            p = self._symbol_point(symbol)
            min_dist = float(self.ATR_MIN_PIPS) * p
            if sl_dist < min_dist: sl_dist = min_dist
            if tp_dist < min_dist: tp_dist = min_dist
        if side.upper() == "BUY": sl = entry_price - sl_dist; tp = entry_price + tp_dist
        else:                      sl = entry_price + sl_dist; tp = entry_price - tp_dist
        return (round(sl, 5), round(tp, 5))

    def _compute_sltp(self, side: str, entry_price: float, symbol: str) -> Tuple[Optional[float], Optional[float]]:
        if self.SLTP_MODE == "ATR":
            sl, tp = self._compute_sltp_atr(side, entry_price, symbol)
            if sl is not None and tp is not None:
                return sl, tp
        return self._compute_sltp_fixed(side, entry_price, symbol)

    # ---- per-symbol override helpers ----
    def _canon_for_broker(self, broker_symbol: str) -> Optional[str]:
        return self._broker_to_canon.get(broker_symbol)

    def _override_or(self, canon: Optional[str], base: float, prefix: str) -> float:
        """Read env override like RISK_PCT_XAUUSD; fall back to base if not set/invalid."""
        if not canon:
            return base
        key = f"{prefix}_{canon}"
        v = os.environ.get(key)
        if v is None:
            return base
        try:
            return float(v)
        except Exception:
            return base

    # ---- sizing helpers ----
    def _stop_distance_for_sizing(self, side: str, entry_price: float, symbol: str) -> Optional[float]:
        """Return SL distance in price units to feed the sizer."""
        if self.SLTP_MODE == "ATR" and ATR_HELPER:
            try:
                atr_value, _ = ATR_HELPER(symbol, period=int(self.ATR_PERIOD), timeframe=self.ATR_TF, bars=int(self.ATR_BARS))
                if atr_value and atr_value > 0:
                    return float(self.ATR_MULT_SL) * float(atr_value)
            except Exception:
                pass
        # fallback: fixed pips converted to price units
        p = self._symbol_point(symbol)
        return max(0.0, float(self.FIXED_PIPS)) * p

    def _compute_volume(self, requested_volume: float, side: str, entry_price: float, symbol: str) -> Tuple[float, dict]:
        """Return (volume_lots, diag). Overrides requested_volume when ATR_RISK is active."""
        canon = self._canon_for_broker(symbol)

        if self.SIZING_MODE != "ATR_RISK" or not POS_SIZER:
            # fixed lot (respect requested if >0 else LOT_SIZE)
            vol = float(requested_volume) if requested_volume and requested_volume > 0 else float(self.LOT_SIZE)
            return vol, {"mode":"fixed_lot", "lot": vol}

        # ATR_RISK with per-symbol overrides
        stop_dist = self._stop_distance_for_sizing(side, entry_price, symbol)
        if not stop_dist or stop_dist <= 0:
            vol = float(self.LOT_SIZE)
            return vol, {"mode":"atr_risk", "reason":"bad_stop_distance_fallback", "lot": vol}

        # Base/global
        risk_pct = float(self.RISK_PCT)
        size_min = float(self.SIZE_MIN) if self.SIZE_MIN else 0.0
        size_max = float(self.SIZE_MAX) if self.SIZE_MAX else 0.0

        # Per-symbol overrides (by canonical)
        risk_pct = self._override_or(canon, risk_pct, "RISK_PCT")
        o_min = self._override_or(canon, size_min, "SIZE_MIN")
        o_max = self._override_or(canon, size_max, "SIZE_MAX")
        size_min, size_max = o_min, o_max

        try:
            lots, diag = POS_SIZER(symbol, stop_distance=stop_dist, risk_pct=risk_pct, default_lot=float(self.LOT_SIZE))
        except Exception as e:
            lots, diag = float(self.LOT_SIZE), {"mode":"atr_risk", "reason": f"sizer_exc:{e}"}

        # optional clamp
        unclamped = float(lots)
        if size_min and lots < size_min: lots = size_min
        if size_max and lots > size_max: lots = size_max

        diag.update({
            "mode":"atr_risk",
            "stop_distance": stop_dist,
            "risk_pct": risk_pct,
            "lots_raw": unclamped,
            "lots_final": float(lots),
            "size_min": size_min or None,
            "size_max": size_max or None,
            "canon": canon
        })
        return float(lots), diag

    # ---- order path ----
    def order_market(self, symbol: str, side: str, volume: float, reason: str = "entry") -> Tuple[bool, Any]:
        do_exec = getenv_bool("EXECUTE", False)
        price = None
        ticket = None

        # Guards
        ok_guard, why, rem = self._guard_check(symbol)
        if not ok_guard:
            self.exec_logger.log_event(symbol=symbol, side=side, volume=volume, price="",
                                       retcode=why, comment=f"blocked by {why.lower()} ({rem:0.1f}s)", ticket="",
                                       reason=reason, extra={})
            return False, {"error": f"blocked: {why}", "remaining_sec": rem}

        # Price snapshot
        try:
            if MT5:
                tick = MT5.symbol_info_tick(symbol)
                price = (tick.ask if side.upper()=="BUY" else tick.bid) if tick else None
        except Exception:
            price = None

        # Sizing (may override requested volume)
        eff_vol, size_diag = self._compute_volume(volume, side, price or 0.0, symbol)

        # Mark in-flight and log attempt
        self._guard_mark_after_attempt(symbol)
        self.exec_logger.log_event(symbol=symbol, side=side, volume=eff_vol, price=price or "",
                                   retcode="ATTEMPT", comment=f"attempt {reason}", ticket="",
                                   reason=reason, extra={"execute": do_exec, "sltp_mode": self.SLTP_MODE, "sizing": self.SIZING_MODE, "size_diag": size_diag})

        if not do_exec:
            self._guard_mark_after_order(symbol)
            self.exec_logger.log_event(symbol=symbol, side=side, volume=eff_vol, price=price or "",
                                       retcode="SIM", comment="simulate only (EXECUTE=0)", ticket="",
                                       reason=reason, extra={})
            return True, {"simulated": True, "volume": eff_vol}

        if not self.adapter:
            self.exec_logger.log_event(symbol=symbol, side=side, volume=eff_vol, price=price or "",
                                       retcode="NOADAPTER", comment="adapter missing", ticket="",
                                       reason=reason, extra={})
            return False, {"error":"adapter missing"}

        # Real execution
        try:
            res = self.adapter.order_market(symbol, side.upper(), eff_vol)
            retcode = res.get("retcode") if isinstance(res, dict) else None
            comment = res.get("comment") if isinstance(res, dict) else ""
            ticket = res.get("ticket") if isinstance(res, dict) else None
            ok = (bool(res.get("ok", False)) if isinstance(res, dict) else bool(res)) or _retcode_ok(retcode, comment)

            self._guard_mark_after_order(symbol)
            self.exec_logger.log_event(symbol=symbol, side=side, volume=eff_vol, price=price or "",
                                       retcode=retcode if retcode is not None else ("OK" if ok else "FAIL"),
                                       comment=comment, ticket=ticket or "",
                                       reason=reason, extra={"adapter": res, "size_diag": size_diag})

            if ok:
                self._apply_sltp(ticket=(int(ticket) if ticket is not None else None),
                                 symbol=symbol, side=side, entry_price=price)
            return ok, {"retcode": retcode, "comment": comment, "ticket": ticket, "volume": eff_vol}
        except Exception as e:
            self.exec_logger.log_event(symbol=symbol, side=side, volume=eff_vol, price=price or "",
                                       retcode="EXC", comment=str(e), ticket="",
                                       reason=reason, extra={"trace": traceback.format_exc(), "size_diag": size_diag})
            return False, {"error": str(e)}

    # ---- SL/TP apply ----
    def _find_position(self, symbol: str, ticket: Optional[int]):
        if not MT5: return None
        try:
            pos_list = MT5.positions_get(symbol=symbol)
            if not pos_list: return None
            if ticket is not None:
                for p in pos_list:
                    try:
                        if int(p.ticket) == int(ticket): return p
                    except Exception: pass
            try: return max(pos_list, key=lambda p: getattr(p, "time_msc", 0))
            except Exception: return pos_list[0]
        except Exception: return None

    def _apply_sltp(self, ticket: Optional[int], symbol: str, side: str, entry_price: Optional[float]) -> None:
        if not MT5: return
        the_pos = self._find_position(symbol, ticket)
        if not the_pos: return
        base_price = float(entry_price) if entry_price else float(getattr(the_pos, "price_open", 0.0))
        if base_price <= 0: return
        sl, tp = self._compute_sltp(side, base_price, symbol)
        if sl is None or tp is None: return
        try:
            req = {"action": MT5.TRADE_ACTION_SLTP, "position": int(the_pos.ticket), "symbol": symbol,
                   "sl": sl, "tp": tp, "magic": 777123, "comment": f"set_sltp_{self.SLTP_MODE.lower()}"}
            res = MT5.order_send(req)
            ret = getattr(res, "retcode", None)
            ok = (ret == MT5.TRADE_RETCODE_DONE)
            self.exec_logger.log_event(symbol=symbol, side=side, volume=getattr(the_pos,"volume",""),
                                       price=base_price, retcode=(ret if ret is not None else ("OK" if ok else "FAIL")),
                                       comment=(f"SLTP set {self.SLTP_MODE} " +
                                                (f"[{self.ATR_TF} P{self.ATR_PERIOD} x{self.ATR_MULT_SL}/{self.ATR_MULT_TP}]"
                                                 if self.SLTP_MODE=="ATR" else f"[{self.FIXED_PIPS}p x{self.TP_MULT}]")),
                                       ticket=int(the_pos.ticket), reason="sltp", extra={"sl":sl,"tp":tp})
        except Exception as e:
            self.exec_logger.log_event(symbol=symbol, side=side, volume=getattr(the_pos,"volume",""),
                                       price=base_price, retcode="EXC",
                                       comment=f"SLTP set failed: {e}", ticket=int(getattr(the_pos,"ticket",0)),
                                       reason="sltp", extra={"trace": traceback.format_exc()})

# ------------- dashboard attach -------------
def start_dashboard_async(controller: TradingController):
    if not MiniDashboard:
        print("[ui] dashboard not available; running headless"); return
    def _run():
        try:
            ui = MiniDashboard(controller)
            ui.run()
        except Exception as e:
            print(f"[ui] dashboard error: {e}")
    threading.Thread(target=_run, daemon=True).start()
    print("[ui] dashboard thread started")

# ------------- broker/ftmo setup -------------
def setup_broker_and_ftmo():
    adapter = None; ftmo_guard = None
    if Adapter:
        try:
            adapter = Adapter()
            login  = os.environ.get("MT5_LOGIN")
            pwd    = os.environ.get("MT5_PASSWORD")
            server = os.environ.get("MT5_SERVER")
            ok, msg = adapter.connect(login, pwd, server)
            print(f"[adapter] connect(l,*,s) -> ok={ok} message={msg}")
        except Exception as e:
            print(f"[adapter] connect failed: {e}")
    if FTMO:
        try:
            daily_loss_limit = getenv_float("FTMO_DAILY_LOSS", -5000.0)
            max_dd_limit     = getenv_float("FTMO_MAX_DD", -10000.0)
            state_path_str   = os.environ.get("FTMO_STATE", str(Path("data") / "ftmo_state.json"))
            state_path = Path(state_path_str); state_path.parent.mkdir(parents=True, exist_ok=True)
            ftmo_guard = FTMO(daily_loss_limit, max_dd_limit, str(state_path))
            print(f"[ftmo] enforcer ready (daily_loss={daily_loss_limit}, max_dd={max_dd_limit}, state={state_path})")
        except Exception as e:
            print(f"[ftmo] disabled: {e}")
            ftmo_guard = None
    if MT5:
        try:
            info = MT5.terminal_info()
            if info is None:
                term = os.environ.get("MT5_TERMINAL_PATH") or os.environ.get("TERMINAL_PATH")
                kw = {}
                if term: kw["path"] = term
                login  = os.environ.get("MT5_LOGIN")
                pwd    = os.environ.get("MT5_PASSWORD")
                server = os.environ.get("MT5_SERVER")
                ok = MT5.initialize(login=int(login), password=pwd, server=server, **kw) if (login and pwd and server) else MT5.initialize(**kw)
                print(f"[mt5] initialize -> {ok}")
        except Exception as e:
            print(f"[mt5] init failed: {e}")
    return adapter, ftmo_guard

# ------------- main -------------
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--no-ui", action="store_true")
    parser.add_argument("--no-log", action="store_true")
    args = parser.parse_args()

    app_mode = os.environ.get("APP_MODE") or ""
    profile = os.environ.get("PROFILE") or "default"
    symbols_env = os.environ.get("SYMBOLS") or "XAUUSD,US30USD,NAS100USD,SPX500USD,BTCUSD,WTICOUSD"
    canonical_symbols = parse_symbols(symbols_env)
    mapping_overrides = {k[4:]: v for k, v in os.environ.items() if k.startswith("MAP_") and v}

    print("[OK] Settings loaded")
    print(f"  mode={app_mode or 'live'}  log={'OFF' if args.no_log or not getenv_bool('LOG_EXEC', True) else 'ON'}  server={os.environ.get('MT5_SERVER') or 'n/a'}")
    print(f"  Symbols: {', '.join(canonical_symbols)}")

    adapter, ftmo_guard = setup_broker_and_ftmo()
    exec_logger = ExecLogger(profile=profile, enabled=(not args.no_log and getenv_bool("LOG_EXEC", True)))

    controller = TradingController(profile=profile, adapter=adapter, ftmo_guard=ftmo_guard,
                                   exec_logger=exec_logger, args=args)

    controller.attach_symbols(canonical_symbols, mapping_overrides)
    controller.mt5_select_all()

    if not args.no_ui:
        start_dashboard_async(controller)

    try:
        controller.pause()
        controller.run()
    except KeyboardInterrupt:
        print("\n[shutdown] Ctrl-C")
    except Exception as e:
        print(f"[fatal] {e}\n{traceback.format_exc()}")
    finally:
        try: controller.shutdown()
        except Exception: pass
        print("[bye] run_live exiting")

if __name__ == "__main__":
    main()
# ===== [PATCH] sizing_mode hooks (safe, idempotent) =====
def _ex_bind_sizing_hooks(ctrl):
    """
    Bind ctrl.set_sizing_mode(mode) / ctrl.get_sizing_mode() and
    keep ctrl.SIZING_MODE sticky via a tiny guardian thread.
    """
    # If methods already present, still ensure guardian is running exactly once.
    already = hasattr(ctrl, "set_sizing_mode") and hasattr(ctrl, "get_sizing_mode")

    # Determine initial mode from existing attribute; default FIXED_LOT.
    try:
        cur = str(getattr(ctrl, "SIZING_MODE", "FIXED_LOT")).upper()
    except Exception:
        cur = "FIXED_LOT"
    if cur not in ("FIXED_LOT", "ATR_RISK"):
        cur = "FIXED_LOT"
    try: setattr(ctrl, "_sizing_mode", cur)
    except Exception: pass

    def _apply(m):
        # Apply selected mode to both the mirror and legacy attr.
        try: setattr(ctrl, "_sizing_mode", m)
        except Exception: pass
        try: setattr(ctrl, "SIZING_MODE", m)
        except Exception: pass

    def _set(mode):
        m = str(mode).upper()
        if m not in ("FIXED_LOT", "ATR_RISK"):
            return False
        _apply(m)
        try: print(f"[controller] SIZING_MODE -> {m}")
        except Exception: pass
        return True

    def _get():
        try:
            return getattr(ctrl, "_sizing_mode")
        except Exception:
            try:
                return str(getattr(ctrl, "SIZING_MODE", "FIXED_LOT")).upper()
            except Exception:
                return "FIXED_LOT"

    # Bind methods if not already bound
    if not already:
        try:
            import types
            ctrl.set_sizing_mode = types.MethodType(lambda self, mode: _set(mode), ctrl)
            ctrl.get_sizing_mode = types.MethodType(lambda self: _get(), ctrl)
        except Exception:
            ctrl.set_sizing_mode = _set
            ctrl.get_sizing_mode = _get

    # Start a single guardian thread to keep attr sticky
    try:
        import threading, time
        if not getattr(ctrl, "_sizing_guard_started", False):
            setattr(ctrl, "_sizing_guard_started", True)
            def _guard():
                # Re-apply selected mode periodically so any external resets are overridden.
                while True:
                    try:
                        _apply(_get())
                    except Exception:
                        pass
                    time.sleep(0.25)
            t = threading.Thread(target=_guard, name="sizing_guard", daemon=True)
            t.start()
    except Exception:
        pass

    return True
# ===== /[PATCH] =====


# ===== [PATCH] exit management hooks (idempotent) =====
def _ex_bind_exit_hooks(ctrl):
    """
    Adds:
      - ctrl.set_break_even(enable, trigger_pips, lock_pips)
      - ctrl.get_break_even() -> dict
      - ctrl.set_trailing(enable, type, atr_mult, step_pips)
      - ctrl.get_trailing() -> dict
    Stores values on the controller so other code can read them.
    """
    # Initialize defaults from existing attributes or sane defaults
    def _bool(name, d=False):
        try: return bool(getattr(ctrl, name))
        except Exception: return d
    def _float(name, d=0.0):
        try: return float(getattr(ctrl, name))
        except Exception: return d
    def _str(name, d=""):
        try: return str(getattr(ctrl, name))
        except Exception: return d

    be_enable = _bool("BE_ENABLE", False)
    be_trig   = _float("BE_TRIGGER_PIPS", 50.0)
    be_lock   = _float("BE_LOCK_PIPS", 5.0)

    tr_enable = _bool("TRAIL_ENABLE", False)
    tr_type   = (_str("TRAIL_TYPE", "ATR") or "ATR").upper()
    if tr_type not in ("ATR","PIPS"): tr_type = "ATR"
    tr_atr    = _float("TRAIL_ATR_MULT", 1.0)
    tr_step   = _float("TRAIL_STEP_PIPS", 20.0)

    # Apply to controller attributes
    setattr(ctrl, "BE_ENABLE", be_enable)
    setattr(ctrl, "BE_TRIGGER_PIPS", be_trig)
    setattr(ctrl, "BE_LOCK_PIPS", be_lock)
    setattr(ctrl, "TRAIL_ENABLE", tr_enable)
    setattr(ctrl, "TRAIL_TYPE", tr_type)
    setattr(ctrl, "TRAIL_ATR_MULT", tr_atr)
    setattr(ctrl, "TRAIL_STEP_PIPS", tr_step)

    # Methods
    def _set_be(enable, trig, lock):
        try:
            setattr(ctrl, "BE_ENABLE", bool(enable))
            setattr(ctrl, "BE_TRIGGER_PIPS", float(trig))
            setattr(ctrl, "BE_LOCK_PIPS", float(lock))
            try: print(f"[controller] BE -> enable={bool(enable)} trigger={float(trig)} lock={float(lock)}")
            except Exception: pass
            return True
        except Exception:
            return False

    def _get_be():
        return {
            "enable": bool(getattr(ctrl, "BE_ENABLE", False)),
            "trigger_pips": float(getattr(ctrl, "BE_TRIGGER_PIPS", 50.0)),
            "lock_pips": float(getattr(ctrl, "BE_LOCK_PIPS", 5.0)),
        }

    def _set_tr(enable, ttype, atr_mult, step_pips):
        try:
            t = str(ttype).upper()
            if t not in ("ATR","PIPS"): t = "ATR"
            setattr(ctrl, "TRAIL_ENABLE", bool(enable))
            setattr(ctrl, "TRAIL_TYPE", t)
            setattr(ctrl, "TRAIL_ATR_MULT", float(atr_mult))
            setattr(ctrl, "TRAIL_STEP_PIPS", float(step_pips))
            try: print(f"[controller] TRAIL -> enable={bool(enable)} type={t} atrx={float(atr_mult)} step={float(step_pips)}")
            except Exception: pass
            return True
        except Exception:
            return False

    def _get_tr():
        return {
            "enable": bool(getattr(ctrl, "TRAIL_ENABLE", False)),
            "type": str(getattr(ctrl, "TRAIL_TYPE", "ATR")).upper(),
            "atr_mult": float(getattr(ctrl, "TRAIL_ATR_MULT", 1.0)),
            "step_pips": float(getattr(ctrl, "TRAIL_STEP_PIPS", 20.0)),
        }

    # Bind if missing
    if not hasattr(ctrl, "set_break_even"): ctrl.set_break_even = _set_be
    if not hasattr(ctrl, "get_break_even"): ctrl.get_break_even = _get_be
    if not hasattr(ctrl, "set_trailing"):   ctrl.set_trailing   = _set_tr
    if not hasattr(ctrl, "get_trailing"):   ctrl.get_trailing   = _get_tr
    return True
# ===== /[PATCH] =====

# ===== [PATCH] exit manager (MT5) =====
def _ex_start_exit_daemon(ctrl):
    """
    Starts a daemon thread that enforces:
      - Break-Even: when profit_points >= BE_TRIGGER_PIPS, set SL to entry +/- BE_LOCK_PIPS
      - Trailing (PIPS): maintains SL trailing by TRAIL_STEP_PIPS behind current price
    Never widens SL. Only tightens/improves.
    Requires MetaTrader5 to be initialized by your adapter (already done).
    """
    try:
        import threading, time
        import MetaTrader5 as mt5
        from tools.atr_helper import get_atr
    except Exception:
        print("[exit] MT5 not available; exits disabled")
        return False

    if getattr(ctrl, "_exit_daemon_started", False):
        return True
    setattr(ctrl, "_exit_daemon_started", True)

    # Tiny helpers
    def _sym_info(sym):
        si = mt5.symbol_info(sym)
        if not si:
            return None, None
        return si.point, si

    def _tick(sym):
        t = mt5.symbol_info_tick(sym)
        return t

    def _pos_list():
        try:
            ps = mt5.positions_get()
            return ps or []
        except Exception:
            return []

    def _better_sl(cur_sl, desired_sl, side_buy):
        # For BUY: better if desired_sl > cur_sl (tighten up)
        # For SELL: better if desired_sl < cur_sl
        if cur_sl in (None, 0.0):
            return True
        if side_buy:
            return desired_sl > float(cur_sl) + 1e-9
        else:
            return desired_sl < float(cur_sl) - 1e-9

    def _apply_sl(position, new_sl, reason=""):
        # Modify position SL via order_send TRADE_ACTION_SLTP (keep existing TP)
        req = {
            "action": mt5.TRADE_ACTION_SLTP,
            "position": position.ticket,
            "symbol": position.symbol,
            "sl": float(new_sl),
            "tp": float(position.tp) if position.tp not in (None, 0.0) else 0.0,
            "magic": getattr(position, "magic", 0),
            "comment": "exits/auto",
        }
        res = mt5.order_send(req)
        ok = (res and getattr(res, "retcode", None) in (mt5.TRADE_RETCODE_DONE, mt5.TRADE_RETCODE_PLACED, 10009))

        # --- CSV log (logs\exits.csv)
        try:
            root = os.path.dirname(os.path.abspath(__file__))
            logdir = os.path.join(root, "logs")
            os.makedirs(logdir, exist_ok=True)
            path = os.path.join(logdir, "exits.csv")
            exists = os.path.exists(path)
            with open(path, "a", newline="", encoding="utf-8") as f:
                w = csv.writer(f)
                if not exists:
                    w.writerow(["ts_iso","ticket","symbol","side","reason","old_sl","new_sl","retcode","ok"])
                side = "BUY" if position.type == 0 else "SELL"
                old_sl = float(position.sl) if position.sl not in (None,) else 0.0
                ts = datetime.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"
                w.writerow([ts, position.ticket, position.symbol, side, str(reason), old_sl, float(new_sl), getattr(res,'retcode',None), bool(ok)])
        except Exception as _e:
            pass

        print(f"[exit] modify ticket={position.ticket} sl->{new_sl:.5f} ret={getattr(res,'retcode',None)} ok={ok} reason={reason}")
        return ok

    def _loop():
        last_run = 0.0
        while True:
            try:
                # run at ~2Hz
                now = time.time()
                if now - last_run < 0.5:
                    time.sleep(0.25); continue
                last_run = now

                # Snap controller config once per pass
                be_cfg = {
                    "enable": bool(getattr(ctrl, "BE_ENABLE", False)),
                    "trigger": float(getattr(ctrl, "BE_TRIGGER_PIPS", 50.0)),
                    "lock": float(getattr(ctrl, "BE_LOCK_PIPS", 5.0)),
                }
                tr_cfg = {
                    "enable": bool(getattr(ctrl, "TRAIL_ENABLE", False)),
                    "type":  str(getattr(ctrl, "TRAIL_TYPE", "PIPS")).upper(),
                    "atrx":  float(getattr(ctrl, "TRAIL_ATR_MULT", 1.0)),
                    "step":  float(getattr(ctrl, "TRAIL_STEP_PIPS", 20.0)),
                }

                if not (be_cfg["enable"] or tr_cfg["enable"]):
                    time.sleep(0.25); continue

                for p in _pos_list():
                    sym = p.symbol
                    point, si = _sym_info(sym)
                    if not point:
                        continue
                    t = _tick(sym)
                    if not t: continue

                    side_buy = (p.type == 0)  # 0=BUY, 1=SELL
                    price_open = float(p.price_open)
                    price_cur  = float(t.bid if side_buy else t.ask)  # conservative
                    cur_sl     = float(p.sl) if p.sl not in (None,) else 0.0

                    # Profit in "points" (your earlier logs used 'p' as points)
                    profit_points = (price_cur - price_open)/point if side_buy else (price_open - price_cur)/point

                    desired_sl = None
                    desired_reason = None

                    # Break-Even first (if enabled & triggered)
                    if be_cfg["enable"] and profit_points >= be_cfg["trigger"]:
                        lock_pts = max(0.0, be_cfg["lock"])
                        if side_buy:
                            desired_sl = price_open + lock_pts * point
                        else:
                            desired_sl = price_open - lock_pts * point
                        desired_reason = "BE"

                    # Trailing (PIPS) next (ATR type is TODO)
                    if tr_cfg["enable"]:
                        if tr_cfg["type"] == "PIPS":
                            step_pts = max(0.0, tr_cfg["step"]) * point
                            trail_sl = (price_cur - step_pts) if side_buy else (price_cur + step_pts)
                            if desired_sl is None:
                                desired_sl = trail_sl
                                desired_reason = ("TRAIL_PIPS" if desired_reason is None else desired_reason + "+TRAIL_PIPS")
                            else:
                                # choose the tighter one (more protective)
                                if side_buy:
                                    desired_sl = max(desired_sl, trail_sl)
                                else:
                                    desired_sl = min(desired_sl, trail_sl)
                                desired_reason = ("TRAIL_PIPS" if desired_reason is None else desired_reason + "+TRAIL_PIPS")
                        else:
                                                        # ATR trailing
                            # Pull ATR (price units), then convert to "points".
                            try:
                                atr_tf   = str(getattr(ctrl, "ATR_TF",  "M5"))
                                atr_per  = int(getattr(ctrl, "ATR_PERIOD", 14))
                                atr_bars = int(getattr(ctrl, "ATR_BARS",   200))
                                atr_floor_pts = float(getattr(ctrl, "ATR_FLOOR_POINTS", 0.0))
                            except Exception:
                                atr_tf, atr_per, atr_bars, atr_floor_pts = "M5", 14, 200, 0.0
                            try:
                                atr_price = float(get_atr(sym, timeframe=atr_tf, period=atr_per, bars=atr_bars) or 0.0)
                            except Exception:
                                atr_price = 0.0
                            atr_points = max(atr_floor_pts, (atr_price / point) if point else 0.0)
                            dist_points = max(0.0, tr_cfg["atrx"]) * atr_points
                            trail_sl = (price_cur - dist_points * point) if side_buy else (price_cur + dist_points * point)
                            if desired_sl is None:
                                desired_sl = trail_sl
                            else:
                                if side_buy:
                                    desired_sl = max(desired_sl, trail_sl)
                                else:
                                    desired_sl = min(desired_sl, trail_sl)

                    if desired_sl is None:
                        continue

                    # Never widen SL
                    if _better_sl(cur_sl, desired_sl, side_buy):
                        _apply_sl(p, desired_sl, desired_reason or "")

            except Exception as e:
                try:
                    print(f"[exit] loop error: {e}")
                except Exception:
                    pass
            finally:
                time.sleep(0.25)

    thr = threading.Thread(target=_loop, name="exit_daemon", daemon=True)
    thr.start()
    print("[exit] daemon started")
    return True
# ===== /[PATCH] =====



# ===== [PATCH] per-symbol risk & ATR mult helpers =====
def _ex_norm_sym(sym: str) -> str:
    try:
        return str(sym).strip().upper()
    except Exception:
        return ""

def _ex_get_env_like(ctrl, key, default=None):
    # Try attribute then os.environ-like dict if present
    import os
    try:
        if hasattr(ctrl, "ENV") and isinstance(ctrl.ENV, dict) and key in ctrl.ENV:
            return ctrl.ENV.get(key, default)
    except Exception:
        pass
    try:
        return os.environ.get(key, default)
    except Exception:
        return default

def _ex_get_risk_pct(ctrl, symbol: str) -> float:
    sym = _ex_norm_sym(symbol)
    # Per-symbol override, else global RISK_PCT
    val = _ex_get_env_like(ctrl, f"RISK_PCT_{sym}", None)
    if val is None:
        try:
            return float(getattr(ctrl, "RISK_PCT", 0.50))
        except Exception:
            return 0.50
    try:
        return float(val)
    except Exception:
        return 0.50

def _ex_get_atr_mults(ctrl, symbol: str):
    sym = _ex_norm_sym(symbol)
    def _num(k, d):
        v = _ex_get_env_like(ctrl, k, None)
        if v is None:
            try:
                return float(getattr(ctrl, k, d))
            except Exception:
                return d
        try:
            return float(v)
        except Exception:
            return d
    sl = _num(f"ATR_MULT_SL_{sym}", _num("ATR_MULT_SL", 1.00))
    tp = _num(f"ATR_MULT_TP_{sym}", _num("ATR_MULT_TP", 2.00))
    return sl, tp

def _ex_bind_per_symbol_api(ctrl):
    # Public getters for other modules / GUI
    if not hasattr(ctrl, "get_risk_pct"):
        ctrl.get_risk_pct = lambda symbol: _ex_get_risk_pct(ctrl, symbol)
    if not hasattr(ctrl, "get_atr_mults"):
        ctrl.get_atr_mults = lambda symbol: _ex_get_atr_mults(ctrl, symbol)
    return True
# ===== /[PATCH] =====

# ===== [PATCH] wrap _compute_volume to inject per-symbol risk =====
def _ex_wrap_sizer_per_symbol(ctrl):
    if not hasattr(ctrl, "_compute_volume"):
        return False
    if getattr(ctrl, "_ex_sizer_sym_wrapped", False):
        return True
    _orig = ctrl._compute_volume
    def _wrapped(requested, side, price, symbol):
        # If mode is ATR_RISK, reinterpret "requested" as risk% (global default),
        # but replace with per-symbol override if present.
        try:
            mode = str(getattr(ctrl, "SIZING_MODE", "FIXED_LOT")).upper()
        except Exception:
            mode = "FIXED_LOT"
        if mode == "ATR_RISK":
            # requested is expected as percent (e.g., 0.50)
            rpct = _ex_get_risk_pct(ctrl, symbol)
            try: requested = float(rpct)
            except Exception: pass
        lots, diag = _orig(requested, side, price, symbol)
        # keep diag consistent
        try:
            if isinstance(diag, dict):
                slm, tpm = _ex_get_atr_mults(ctrl, symbol)
                diag = dict(diag); diag["risk_pct_used"] = requested; diag["atr_mult_sl"], diag["atr_mult_tp"] = slm, tpm
        except Exception:
            pass
        return lots, diag
    try:
        import types
        ctrl._compute_volume = types.MethodType(_wrapped, ctrl)
    except Exception:
        ctrl._compute_volume = _wrapped
    setattr(ctrl, "_ex_sizer_sym_wrapped", True)
    print("[sizing] per-symbol risk wrapper active")
    return True
# ===== /[PATCH] =====



# ===== [PATCH] auto-exits runtime API =====
def _ex_auto_exits_api(ctrl):
    """
    Adds:
      - ctrl.set_auto_exits(enabled: bool)
      - ctrl.get_auto_exits() -> bool
    Starts or stops the exit daemon cleanly.
    """
    def _get_enabled():
        try:
            import os
            if str(getattr(ctrl, "EXIT_DAEMON_DISABLE", os.environ.get("EXIT_DAEMON_DISABLE","0"))).strip().lower() in ("1","true","yes","on"):
                return False
        except Exception:
            pass
        return True

    def _set_enabled(enabled: bool):
        enabled = bool(enabled)
        try:
            # flip attr (env remains as-is)
            setattr(ctrl, "EXIT_DAEMON_DISABLE", (not enabled))
        except Exception:
            pass

        if not enabled:
            # request graceful stop; thread checks this quickly and exits
            try: setattr(ctrl, "_exit_daemon_should_stop", True)
            except Exception: pass
            try: print("[exit] auto_exits -> OFF (stop requested)")
            except Exception: pass
            return True

        # enabling: clear stop flag and (re)start if not running
        try: setattr(ctrl, "_exit_daemon_should_stop", False)
        except Exception: pass
        if not getattr(ctrl, "_exit_daemon_started", False):
            try:
                _ex_start_exit_daemon(ctrl)
            except Exception as e:
                try: print(f"[exit] auto_exits start failed: {e}")
                except Exception: pass
                return False
        try: print("[exit] auto_exits -> ON")
        except Exception: pass
        return True

    if not hasattr(ctrl, "set_auto_exits"): ctrl.set_auto_exits = _set_enabled
    if not hasattr(ctrl, "get_auto_exits"): ctrl.get_auto_exits = _get_enabled
    return True
# ===== /[PATCH] =====



